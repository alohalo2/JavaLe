Set(Interface)에 대한 정의


Set은 쉽게 말해서 집합이라고 보시면 된다.

 
기본적으로 Set혹은 Set계열을 구현하는 클래스들은 다음과 같은 공통점이 있다.

1. 중복되는 요소(원소)를 허용하지 않는다.
2. 저장 순서를 유지하지 않는다. (LinkedHashSet 만 예외)

여기서 가장 눈여겨보아야 할 것은 '중복되는 요소를 허용하지 않는다.' 이다.
이전까지의 구현했던 자료구조는 중복 상관 없이 데이터를 추가했었지만, Set의 경우는 중복 요소를 허용하지 않는다. 이는 Java뿐만 아니라 다른 언어 또한 마찬가지다.

<Set 쓰임새>
1. 집합 관련 문제
2. 중복 처리를 고려해야할 때
3. 2번 사항 + 빠르게 찾아야할 때

Hash 알고리즘을 이용한 HashSet
이진 탐색 트리를 사용하여 오름차순 정렬까지 해주는 TreeSet
Set에 순서를 부여해주는 LinkedHashSet

<HashSet>
가장 기본적인 Set 컬렉션의 클래스인데, 입력 순서를 보장하지 않고, 순서도 마찬가지로 보장되지 않는다. 

가장 쉽게 이해할 수 있는 예로는 여러분이 게임에서 '닉네임'을 만든다거나 아이디를 생성할 때 '중복확인'을 눌러 중복된 닉네임 또는 아이디인지 확인하는 것이다. 
이는 데이터가 정렬되어있을 필요도 없고, 빠르게 중복되는 값인지만 찾으면 되기 때문에 유용한 방법이 될 수 있다.

좀 더 상세하게 말하자면 hash에 의해 데이터의 위치를 특정시켜 해당 데이터를 빠르게 색인(search)할 수 있게 만든 것이다. 
즉, Hash 기능과 Set컬렉션이 합쳐진 것이 HashSet이다. 그렇기 때문에 삽입, 삭제, 색인이 매우 빠른 컬렉션 중 하나다.

 

<LinkedHashSet>
Link + Hash + Set 이 결합된 형태다. 
LinkedList에서 보면 add() 메소드를 통해 요소들을 넣은 순서대로 연결한다. 
즉, LinkedList의 첫번째 요소부터 차례대로 출력하면 입력했던 순서대로 출력된다는 것이고 이는 순서를 보장한다는 의미다.

Set의 경우 기본적으로 입력 순서대로의 저장순서를 보장하지 않아 '중복은 허용하지 않으면서 순서를 보장받고 싶은경우'에는 불편할 수밖에 없다. 
이를 보완하기 위해 존재하는 것이 바로 LinkedHashSet인 것이다. 실생활에서 그나마 예로 들자면 페이지를 열 때 만약 해당 페이지가 중복되경우 cache는 다시 적재할 필요는 없지만, 
새로운 페이지를 할당해야 할 경우 최근에 사용되지 않은 cache을 비우고자 할 때, 가장 오래된 cache를 비우는 것이 현명할 것이다. 
이를 LRU 알고리즘(Least Recently Used Algorithm)이라고 하는데, 이럴 때 입력된(저장된) 순서를 알아야 오래된 캐시를 비울 수 있다. 
이에 적용할 수 있는 자료구조 중 하나다. (현실적으로는 LRU기법으로 LinkedHashMap이라는 자료구조가 대부분을 차지하고 있어 많이 쓰이진 않으나 그나마 이해하기 쉬운 예시를 위해..)

 
<TreeSet>
HashSet과 마찬가지로 입력 순서대로의 저장 순서를 보장하지 않으며 중복 데이터 또한 넣지 못한다. 
다만 특별한 점이 있다면 SortedSet Interface의 이름을 보면 알 수 있듯 이를 구현한 TreeSet은 데이터의 '가중치에 따른 순서'대로 정렬되어 보장한다는 것이다. 
앞서 PriorityQueue를 생각해보자. 데이터들이 입력한 순서대로가 아닌 값에 따라 정렬되어 Queue에 담아진다. 
마찬가지로 TreeSet은 '중복되지 않으면서 특정 규칙에 의해 정렬된 형태의 집합을 쓰고 싶을 때 쓴다. 
정렬된 형태로 있다보니 특정 구간의 집합요소들을 탐색할 때 매우 유용하다.

(Tree 라는 자료구조 자체가 데이터를 일정 순서에 의해 정렬하는 구조다. 거기에 더해진 것이 바로 Set인 중복값 방지 자료구조인 것이다.)